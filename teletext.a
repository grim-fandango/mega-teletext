!to "teletext.o", cbm

SCNKEY 	= $ff9f
GETIN 	= $ff34
SCRNPTR = $0800
COLPTR	= $f800

* = $1600

start:      	
				// Lower case mode
				lda #39
				sta 53272

				// Enable VIC-IV mode
				sei
				ldx #$47
				ldy #$53
				stx $d02f
				sty $d02f
				

				// clear H640 - sets screen to 40 column mode
				lda $d031
				and #$7f
				sta $d031

				//set bit 5 
				//ora #$10
				//sta $d031

				// enable 2K colour RAM
				lda $d030
				ora #$01
				sta $d030	

				
				// Move screen RAM
				lda #<SCRNPTR
				sta $d060				
				lda #>SCRNPTR
				sta $d061
				lda #$00
				sta $d062
				sta $d063
				cli

			
				// Enable super extended attribute mode
				lda $d054
				ora #$05
				sta $d054
				
				// Set the bytes required per row to 80
				lda #$50
				sta $d058
				lda #$00
				sta $d059

				// Set the characters to display to 40
				lda #$28
				sta $d05e

				// Set the screen colours to default
				lda #$00
				sta $d020
				sta $d021
				sta $d702
				lda #>dmacoldefault
				sta $d701
				lda #<dmacoldefault
				sta $d700
				jsr triggerdma			

				// Clear screen
				//lda #$00
				//sta $d020
				//sta $d021
				//sta $d702
				//lda #>dmacls
				//sta $d701
				//lda #<dmacls
				//sta $d700
				//jsr triggerdma				

				// Clear screen
loopstart:		ldx #$00
loop:			lda #$20
				sta SCRNPTR,x
				sta SCRNPTR+$100,x
				sta SCRNPTR+$200,x
				sta SCRNPTR+$300,x
				sta SCRNPTR+$400,x
				sta SCRNPTR+$500,x
				sta SCRNPTR+$600,x
				sta SCRNPTR+$700,x
				
				dex
				lda #$00
				sta SCRNPTR,x
				sta SCRNPTR+$100,x
				sta SCRNPTR+$200,x
				sta SCRNPTR+$300,x
				sta SCRNPTR+$400,x
				sta SCRNPTR+$500,x
				sta SCRNPTR+$600,x
				sta SCRNPTR+$700,x
				dex
				bne loop	
	
				//test = insert at this row
				lda #$00
				sta .row

				// ensure row -1 > row < 25, if not set row to row 1
				lda .row
				sbc #$18
				bmi validrow
				lda #$01
				sta .row

validrow:
				// find first location on screen RAM to poke to
				ldx #<SCRNPTR
				ldy #>SCRNPTR
				stx .linestartscrn
				sty .linestartscrn + 1

				ldy .row
				iny

rowloop:		dey
				beq printline				
				clc
				lda .linestartscrn
				adc #80
				sta .linestartscrn
				bcs nextpage
				jmp rowloop
nextpage:		inc .linestartscrn + 1
				jmp rowloop				

				// -------------------------------------------------------

				// Poke string to screen RAM
printline:		
				lda .linestartscrn
				sta screenpoke + 1
				lda .linestartscrn + 1
				sta screenpoke + 2

				lda #$00
				tax
				tay
printloop:		lda .msg,x
				beq end
				cmp #$04
				bne screenpoke
				jsr alphacolour

screenpoke:	 	sta .linestartscrn,y
				inx
				iny
				iny
				jmp printloop

end:			//rts

key:			lda $d4
				cmp #60
				bne key
		

				// turn off super extended attribute mode
				lda $d054
				and #250
				sta $d054
				rts	

				//jmp seamtest
				//lda #$0a
				//sta $0800			
				
				//DMA list test
				lda #$03
				sta .pokeword

				lda #$04
				sta .destlo
				lda #$f8
				sta .desthi
				lda #$01
				sta .destbank

				lda #$00
				sta $d702
				lda #>dmapoke
				sta $d701

				lda #<dmapoke
				sta $d700
				jsr triggerdma

// ------------------------------------------
				//SEAM screen byte test
				// byte 0: 	$80 = inverse video
				// 			$40 = all graphics symbols, can't tell what it's done
				//			$20 = numbers intact, letters are other symbols, can't tell what it's done
				//			$10 = same sort of thing as $20
				//			$08 = same sort of thing again
				//			$04 = same again
				//			$02 = same again
				//			$01 = same again
				// byte 1:  $80 = for kerning
				//			$40 = kerning
				//			$20 = kerning
				//			$10 = all black?
				//			$08 = alternate characters?
				// 			$04 = background colour = foreground colour?
				//			$02 = alternate character set?
				// 			$01 = all black?

seamtest:		ldx #$ff
seamloop:		lda .linestartscrn,x			
				ora #$00
				sta .linestartscrn,x
				dex
				dex
				bne seamloop

// ------------------------------------------


				rts

triggerdma:		lda #$00
				sta $d703
				rts

//---------------------------------------------				

alphacolour:
				// save colour to dmalist				
				sta .pokeword

				// save everything to the stack
				pha
				txa
				pha
				tya
				pha

				// length of colour to apply to take us to the end of the line
				sty .tempbyte
				lda #80
				sbc .tempbyte
				sta $800
				tax
				inx

				// work out the colour RAM location to start from	
				jsr findcolramposn

				// we are poking 1 byte at a time because we have to poke every other byte
				lda #$01
				sta .pokecount

				// loop from the start location, writing to every other byte

colourloop:		lda .linestartcolr
				sta .destlo
				lda .linestartcolr + 1
				sta .desthi

				lda #$01
				sta .destbank

				lda #$00
				sta $d702
				lda #>dmapoke
				sta $d701
				lda #<dmapoke
				sta $d700
				jsr triggerdma

				dex
				beq xcolourloop
				lda .linestartcolr
				adc #$02
				sta .linestartcolr
				bcc colourloop
				inc .linestartcolr + 1
				jmp colourloop

xcolourloop:	pla 
				tay
				pla
				tax
				pla

				rts

findcolramposn:
				pha
				txa
				pha 
				tya
				pha

				// find first location on screen RAM to poke to
				ldx #<COLPTR
				ldy #>COLPTR
				stx .linestartcolr
				sty .linestartcolr + 1

				ldy .row
				iny

				// add in the start column
				lda .linestartcolr
				adc .tempbyte
				sta .linestartcolr

colrowloop:		dey
				beq colexit				
				clc
				lda .linestartcolr
				adc #80
				sta .linestartcolr
				bcs colnextpage
				jmp colrowloop
colnextpage:	inc .linestartcolr + 1
				jmp colrowloop	

colexit:		pla 
				tay
				pla
				tax
				pla
				rts

// --------------------------------------------------------------------------------------
// DATA
// --------------------------------------------------------------------------------------

.curntlinebase:	!word $f800
cursorpos:		!byte 0

dmacoldefault:	!byte $03		; fill
				!word 2000		; count
				!word $01		; value to write
				!byte $00		; bank (ignored for fill)
				!word $f800		; destination
				!byte $01		; bank 1
				!byte $00		; command hi byte
				!word $0000		; modulo (ignored for fill)

dmacls:			!byte $03		; fill
				!word 2000		; count
				!word $20		; value to write
				!byte $00		; bank (ignored for fill)
				!word SCRNPTR	; destination
				!byte $00		; bank 1
				!byte $00		; command hi byte
				!word $0000		; modulo (ignored for fill)

dmacopy:		!byte $00		; copy
				!word 2000		; count
				!word COLPTR	; source base address
				!byte $00		; source bank 
				!word $f800		; destination
				!byte $01		; bank 1
				!byte $00		; command hi byte
				!word $0000		; modulo (ignored for fill)

dmapoke:		!byte $03		; fill
.pokecount		!word 2			; count
.pokeword:		!word $0004		; value to write
				!byte $00		; source bank 
.destlo:		!byte $02		; destination
.desthi:		!byte $f8
.destbank:		!byte $01 		; bank 1
				!byte $00		; command hi byte
				!word $0000		; modulo (ignored for fill)
				
.msg:			!scr "  P100  CEEFAX 100  Thu 18 Jan "		
				!byte $04
	 			!scr "12:01/00"
				!byte 0

.row:			!byte 0
.linestartscrn:	!word 0
.linestartcolr: !word 0
.tempbyte		!byte 0